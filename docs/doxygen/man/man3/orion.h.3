.TH "src/h/orion.h" 3 "Mon Jun 18 2018" "Version 1.0" "Orion" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/h/orion.h
.SH SYNOPSIS
.br
.PP
\fC#include <pthread\&.h>\fP
.br
\fC#include 'catalog\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBOrion\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBORION_MODE_OFF\fP   0"
.br
.ti -1c
.RI "#define \fBORION_MODE_ON\fP   1"
.br
.ti -1c
.RI "#define \fBORION_RATE\fP   1"
.br
.ti -1c
.RI "#define \fBSLEEP_RESOLUTION\fP   1"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBOrion\fP * \fBorion_create\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "int \fBorion_connect\fP (\fBOrion\fP *orion, char *ip, unsigned short port)"
.br
.ti -1c
.RI "int \fBorion_start\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "void \fBorion_track\fP (\fBOrion\fP *orion, \fBcat_entry\fP target)"
.br
.ti -1c
.RI "int \fBorion_stop\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "void \fBorion_disconnect\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "int \fBorion_free\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "int \fBorion_is_running\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "int \fBorion_is_connected\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "double \fBorion_mark_time\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "void \fBorion_clear_error\fP (\fBOrion\fP *orion)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ORION_MODE_OFF   0"

.SS "#define ORION_MODE_ON   1"

.SS "#define ORION_RATE   1"

.SS "#define SLEEP_RESOLUTION   1"

.SH "Function Documentation"
.PP 
.SS "void orion_clear_error (\fBOrion\fP * orion)"
Clears the internal error buffer\&. Thread safe\&. 
.SS "int orion_connect (\fBOrion\fP * orion, char * ip, unsigned short port)"
Connect a socket to the specified sensor using TCP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIip\fP a string holding the ip address of the sensor in dotted quad notation 
.br
\fIport\fP the port of the sensor's socket 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, 1 otherwise\&. Check error buffer after a failure for cause\&. 
.RE
.PP

.SS "\fBOrion\fP* orion_create (\fBOrion\fP * orion)"
Instantiates the given \fBOrion\fP structure, allocating space if the argument is NULL\&. 
.PP
\fBReturns:\fP
.RS 4
a pointer to the instantiated structure regardless if it was allocated\&. 
.RE
.PP

.SS "void orion_disconnect (\fBOrion\fP * orion)"
Disconnects the socket and disposes of resources\&. 
.SS "int orion_free (\fBOrion\fP * orion)"
Frees anciliary structures allocated by orion\&. 
.SS "int orion_is_connected (\fBOrion\fP * orion)"

.PP
\fBReturns:\fP
.RS 4
True if the sensor is connected to the orion server\&. 
.RE
.PP

.SS "int orion_is_running (\fBOrion\fP * orion)"
Best guess of whether the server is running\&. Thread safe\&. 
.PP
\fBReturns:\fP
.RS 4
True if the orion server was running recently\&. False otherwise\&. 
.RE
.PP

.SS "double orion_mark_time (\fBOrion\fP * orion)"
gets a millisecond accurate timestamp from the system, converts it to Julian hours(see Novas 3\&.1 documentation), then sets the current tracker time\&. 
.PP
\fBReturns:\fP
.RS 4
the last marked timestamp\&. 
.RE
.PP

.SS "int orion_start (\fBOrion\fP * orion)"
Starts the main control loop of the \fBOrion\fP sensor in a separate thread\&. Thread safe\&. 
.PP
\fBReturns:\fP
.RS 4
0 on success, 1 on failure\&. Check error buffer after a failure for cause\&. 
.RE
.PP

.SS "int orion_stop (\fBOrion\fP * orion)"
Safely stops the control loop and blocks until it returns\&. Thread safe\&. 
.SS "void orion_track (\fBOrion\fP * orion, \fBcat_entry\fP target)"
Specify a target which the control thread will instruct the sensor to track\&. Thread safe\&. 
.PP
\fBParameters:\fP
.RS 4
\fItarget\fP A novas structure holding the celestial location of the target\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Orion from the source code\&.
