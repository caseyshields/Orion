.TH "src/orion.c" 3 "Mon Jun 18 2018" "Version 1.0" "Orion" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/orion.c
.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include <winsock\&.h>\fP
.br
\fC#include 'novasc3\&.1/novas\&.h'\fP
.br
\fC#include 'h/tracker\&.h'\fP
.br
\fC#include 'h/vmath\&.h'\fP
.br
\fC#include 'h/orion\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBOrion\fP * \fBorion_create\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "int \fBorion_connect\fP (\fBOrion\fP *orion, char *ip, unsigned short port)"
.br
.ti -1c
.RI "void * \fBorion_control_loop\fP (void *arg)"
.br
.ti -1c
.RI "int \fBorion_start\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "void \fBorion_track\fP (\fBOrion\fP *orion, \fBcat_entry\fP target)"
.br
.ti -1c
.RI "int \fBorion_stop\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "void \fBorion_disconnect\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "double \fBorion_mark_time\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "int \fBorion_is_connected\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "int \fBorion_is_running\fP (\fBOrion\fP *orion)"
.br
.ti -1c
.RI "void \fBorion_clear_error\fP (\fBOrion\fP *orion)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void orion_clear_error (\fBOrion\fP * orion)"
Clears the internal error buffer\&. Thread safe\&. 
.SS "int orion_connect (\fBOrion\fP * orion, char * ip, unsigned short port)"
Connect a socket to the specified sensor using TCP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIip\fP a string holding the ip address of the sensor in dotted quad notation 
.br
\fIport\fP the port of the sensor's socket 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, 1 otherwise\&. Check error buffer after a failure for cause\&. 
.RE
.PP

.SS "void* orion_control_loop (void * arg)"

.SS "\fBOrion\fP* orion_create (\fBOrion\fP * orion)"
Instantiates the given \fBOrion\fP structure, allocating space if the argument is NULL\&. 
.PP
\fBReturns:\fP
.RS 4
a pointer to the instantiated structure regardless if it was allocated\&. 
.RE
.PP

.SS "void orion_disconnect (\fBOrion\fP * orion)"
Disconnects the socket and disposes of resources\&. 
.SS "int orion_is_connected (\fBOrion\fP * orion)"

.PP
\fBReturns:\fP
.RS 4
True if the sensor is connected to the orion server\&. 
.RE
.PP

.SS "int orion_is_running (\fBOrion\fP * orion)"
Best guess of whether the server is running\&. Thread safe\&. 
.PP
\fBReturns:\fP
.RS 4
True if the orion server was running recently\&. False otherwise\&. 
.RE
.PP

.SS "double orion_mark_time (\fBOrion\fP * orion)"
gets a millisecond accurate timestamp from the system, converts it to Julian hours(see Novas 3\&.1 documentation), then sets the current tracker time\&. 
.PP
\fBReturns:\fP
.RS 4
the last marked timestamp\&. 
.RE
.PP

.SS "int orion_start (\fBOrion\fP * orion)"
Starts the main control loop of the \fBOrion\fP sensor in a separate thread\&. Thread safe\&. 
.PP
\fBReturns:\fP
.RS 4
0 on success, 1 on failure\&. Check error buffer after a failure for cause\&. 
.RE
.PP

.SS "int orion_stop (\fBOrion\fP * orion)"
Safely stops the control loop and blocks until it returns\&. Thread safe\&. 
.SS "void orion_track (\fBOrion\fP * orion, \fBcat_entry\fP target)"
Specify a target which the control thread will instruct the sensor to track\&. Thread safe\&. 
.PP
\fBParameters:\fP
.RS 4
\fItarget\fP A novas structure holding the celestial location of the target\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Orion from the source code\&.
