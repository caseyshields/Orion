.TH "src/h/catalog.h" 3 "Mon Jun 18 2018" "Version 1.0" "Orion" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/h/catalog.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include 'novasc3\&.1/novas\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBEntry\fP"
.br
.ti -1c
.RI "struct \fBCatalog\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBEntryFunction\fP) (\fBEntry\fP *)"
.br
.ti -1c
.RI "typedef int(* \fBEntryPredicate\fP) (\fBEntry\fP *)"
.br
.ti -1c
.RI "typedef void(* \fBEntryComparison\fP) (\fBEntry\fP *, \fBEntry\fP *)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBentry_print\fP (\fBEntry\fP *e)"
.br
.ti -1c
.RI "\fBCatalog\fP * \fBcatalog_create\fP (\fBCatalog\fP *c, size_t s)"
.br
.ti -1c
.RI "void \fBcatalog_add\fP (\fBCatalog\fP *c, \fBEntry\fP *e)"
.br
.ti -1c
.RI "\fBCatalog\fP * \fBcatalog_load_fk5\fP (\fBCatalog\fP *c, FILE *f)"
.br
.ti -1c
.RI "void \fBcatalog_each\fP (\fBCatalog\fP *c, \fBEntryFunction\fP f)"
.br
.ti -1c
.RI "\fBCatalog\fP * \fBcatalog_filter\fP (\fBCatalog\fP *catalog, \fBEntryPredicate\fP predicate, \fBCatalog\fP *result)"
.br
.ti -1c
.RI "\fBCatalog\fP * \fBcatalog_search_dome\fP (\fBCatalog\fP *catalog, double right_ascension, double declination, double radius, \fBCatalog\fP *results)"
.br
.ti -1c
.RI "\fBCatalog\fP * \fBcatalog_search_patch\fP (\fBCatalog\fP *catalog, double ra_min, double ra_max, double dec_min, double dec_max, \fBCatalog\fP *results)"
.br
.ti -1c
.RI "\fBCatalog\fP * \fBcatalog_orange\fP (\fBCatalog\fP *c, double min, double max, \fBCatalog\fP *results)"
.br
.ti -1c
.RI "void \fBcatalog_print\fP (\fBCatalog\fP *c)"
.br
.ti -1c
.RI "void \fBcatalog_free_entries\fP (\fBCatalog\fP *c)"
.br
.ti -1c
.RI "void \fBcatalog_free\fP (\fBCatalog\fP *c)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* EntryComparison) (\fBEntry\fP *, \fBEntry\fP *)"
A function for ordering catalog entries 
.SS "typedef void(* EntryFunction) (\fBEntry\fP *)"

.SS "typedef int(* EntryPredicate) (\fBEntry\fP *)"
A predicate used in catalog filters to test individual entries\&. 
.SH "Function Documentation"
.PP 
.SS "void catalog_add (\fBCatalog\fP * c, \fBEntry\fP * e)"
Adds the given entry to the catalog, doubling the allocated space if necessary\&. 
.SS "\fBCatalog\fP* catalog_create (\fBCatalog\fP * c, size_t s)"
Creates a new catalog at the given pointer\&. If the 'catalog' reference is NULL a new catalog and entries are allocated using the hint\&. If the reference is valid and 'allocate' is positive, new entries are allocated and the old are freed\&. Otherwise the catalog's pre-existing references are used\&. This allows you to reuse previously allocated catalogs\&. Returns the initialized catalog\&. 
.SS "void catalog_each (\fBCatalog\fP * c, \fBEntryFunction\fP f)"
Applies a void function to every entry in the catalog\&. 
.SS "\fBCatalog\fP* catalog_filter (\fBCatalog\fP * catalog, \fBEntryPredicate\fP predicate, \fBCatalog\fP * result)"
Searches a catalog for Entries for which the predicate function returns true\&. No effort is taken to remove duplicates from the results\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcatalog\fP The catalog to be searched\&. 
.br
\fIpredicate\fP a pointer to a boolean function of an \fBEntry\fP 
.br
\fIresults\fP A catalog to add the matches to\&. If NULL, a new \fBCatalog\fP is allocated\&. Don't forget to de-allocate it! 
.RE
.PP
\fBReturns:\fP
.RS 4
a pointer to the resulting catalog, regardless if the result parameter was set to NULL\&. 
.RE
.PP

.SS "void catalog_free (\fBCatalog\fP * c)"
Releases the \fBCatalog\fP and it's directory, but not the actual Entries\&. 
.SS "void catalog_free_entries (\fBCatalog\fP * c)"
Releases the Entries underlying the \fBCatalog\fP\&. 
.SS "\fBCatalog\fP* catalog_load_fk5 (\fBCatalog\fP * c, FILE * f)"
Loads a FK5 catalog printout from the given file\&. 
.SS "\fBCatalog\fP* catalog_orange (\fBCatalog\fP * c, double min, double max, \fBCatalog\fP * results)"

.SS "void catalog_print (\fBCatalog\fP * c)"
Prints the given catalog to stdout in a default format\&. 
.SS "\fBCatalog\fP* catalog_search_dome (\fBCatalog\fP * catalog, double right_ascension, double declination, double radius, \fBCatalog\fP * results)"
Searches a catalog for entries within the geometry and returns a catalog holding the results\&. No effort is taken to remove duplicates from the results\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcatalog\fP The catalog to be searched\&. 
.br
\fIright_ascension\fP Right ascension of axis of search cone volume in hours\&. 
.br
\fIdeclination\fP Declination of axis of search cone volume in degrees\&. 
.br
\fIradius\fP Angle between axis and edge of search cone volume in degrees\&. 
.br
\fIresults\fP A catalog to add the matches to\&. If NULL, a new \fBCatalog\fP is allocated\&. Don't forget to de-allocate it! 
.RE
.PP
\fBReturns:\fP
.RS 4
a pointer to the resulting catalog, regardless if the result parameter was set to NULL\&. 
.RE
.PP

.SS "\fBCatalog\fP* catalog_search_patch (\fBCatalog\fP * catalog, double ra_min, double ra_max, double dec_min, double dec_max, \fBCatalog\fP * results)"
Searches a catalog for entries within the geometry and returns a catalog holding the results\&. No effort is taken to remove duplicates from the results\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcatalog\fP The catalog to be searched\&. 
.br
\fIra_min\fP Right ascension lower bound, inclusive\&. 
.br
\fIra_max\fP Right ascension upper bound, inclusive\&. 
.br
\fIdec_min\fP Declination lower bound, inclusive\&. 
.br
\fIdec_max\fP Declination upper bound, inclusive\&. 
.br
\fIresults\fP A catalog to add the matches to\&. If NULL, a new \fBCatalog\fP is allocated\&. Don't forget to de-allocate it! 
.RE
.PP

.SS "void entry_print (\fBEntry\fP * e)"

.SH "Author"
.PP 
Generated automatically by Doxygen for Orion from the source code\&.
